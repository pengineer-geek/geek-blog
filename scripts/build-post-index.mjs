import { globby } from "globby";
import fs from "node:fs";
import path from "node:path";
import matter from "gray-matter";

/** ▼ 記事の場所をあなたの構成に合わせて */
const CONTENT_GLOBS = ["content/**/*.mdx"];

/** ▼ 並び順のプリセット（必要に応じて編集） */
const SECTION_ORDER = {
  "diary": 1,
  "column": 2,
  "how-to-setup": 3,
  "tech-intro": 4,
  "gadget": 5,
  "training": 6,
  "nutrition": 7,
  "recovery": 8,
};

const SUB_ORDER_BY_SECTION = {
  /** career */
  "diary": {
    "high-school": 1,
    "university": 2,
    "graduate-school": 3,
    "job-hunting": 4,
    "game-planner": 5,
    "no-job": 6,
    "junior-engineer": 7,
  },

  /** tech  */
  "how-to-setup": {
    "how-to-start": 1,
  },

  /** wellness */
  "training": { weight: 1, bjj: 2 },
  "nutrition": { recipe: 1, supplement: 2 },
  "recovery": { sleep: 1, relax: 2 },
};

/** ---------- ここから処理 ---------- */

function sortPosts(posts) {
  return posts.sort((a, b) => {
    const ao = a.order ?? 0, bo = b.order ?? 0;
    if (ao !== bo) return ao - bo;
    const ad = a.date ? Date.parse(a.date) : 0;
    const bd = b.date ? Date.parse(b.date) : 0;
    if (ad !== bd) return bd - ad; // desc
    return a.title.localeCompare(b.title);
  });
}

function finiteOrInf(n) {
  return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
}

/** サブの順序を決める優先順位
 * 1) frontmatter の subOrder（サブ内で最小値）
 * 2) SUB_ORDER_BY_SECTION の定義
 * 3) 記事の order（サブ内で最小値）
 * 4) 最も古い date（サブ内で最小値）
 * 5) 最後はアルファベット順（tie-breaker）
 */
function calcSubOrder(sectionKey, subKey, posts, presets) {
  const fmMin = Math.min(
    ...posts.map((p) => finiteOrInf(typeof p.subOrder === "number" ? p.subOrder : Infinity))
  );
  if (Number.isFinite(fmMin)) return fmMin;

  const preset = presets?.[sectionKey]?.[subKey];
  if (typeof preset === "number") return preset;

  const orderMin = Math.min(...posts.map((p) => finiteOrInf(typeof p.order === "number" ? p.order : Infinity)));
  if (Number.isFinite(orderMin)) return orderMin;

  const dateMin = Math.min(...posts.map((p) => finiteOrInf(p.date ? Date.parse(p.date) : Infinity)));
  if (Number.isFinite(dateMin)) return dateMin;

  return Number.POSITIVE_INFINITY;
}

const required = ["title", "slug", "sectionKey", "subKey"];

const sectionMap = new Map(); // sectionKey -> Map<subKey, PostMeta[]>
const files = await globby(CONTENT_GLOBS);

for (const f of files) {
  const raw = fs.readFileSync(f, "utf-8");
  const fm = (matter(raw).data ?? {});
  const miss = required.filter((k) => !(k in fm));
  if (miss.length) {
    // 必須が無い mdx は索引対象外（プロフィール等）なので warn だけ
    console.warn(`[post-index] Missing ${miss.join(", ")} in ${f}`);
    continue;
  }
  const meta = {
    title: String(fm.title),
    slug: String(fm.slug).replace(/^\/+|\/+$/g, ""),
    excerpt: fm.excerpt ?? undefined,
    tags: Array.isArray(fm.tags) ? fm.tags : [],
    date: fm.date ?? undefined,
    sectionKey: String(fm.sectionKey),
    subKey: String(fm.subKey),
    order: typeof fm.order === "number" ? fm.order : undefined,
    subOrder: typeof fm.subOrder === "number" ? fm.subOrder : undefined, // ★任意
  };

  if (!sectionMap.has(meta.sectionKey)) sectionMap.set(meta.sectionKey, new Map());
  const subMap = sectionMap.get(meta.sectionKey);
  if (!subMap.has(meta.subKey)) subMap.set(meta.subKey, []);
  subMap.get(meta.subKey).push(meta);
}

/** Map -> Array（posts の並べ替え & sub の並べ替え） */
const sections = [];
for (const [sectionKey, subMap] of sectionMap) {
  const subs = [];
  for (const [subKey, posts] of subMap) {
    const sortedPosts = sortPosts(posts);
    const subOrder = calcSubOrder(sectionKey, subKey, sortedPosts, SUB_ORDER_BY_SECTION);
    subs.push({ key: subKey, order: subOrder, posts: sortedPosts });
  }

  // ★ サブを統一順序で確定
  subs.sort((a, b) => {
    const cmp = (a.order ?? Infinity) - (b.order ?? Infinity);
    return cmp !== 0 ? cmp : a.key.localeCompare(b.key);
  });

  // ★ セクション自体の順序も確定
  const sectionOrder = SECTION_ORDER[sectionKey] ?? Math.min(...subs.map((s) => finiteOrInf(s.order)));
  sections.push({ key: sectionKey, order: sectionOrder, subs });
}

// セクションを最終ソート
sections.sort((a, b) => {
  const cmp = (a.order ?? Infinity) - (b.order ?? Infinity);
  return cmp !== 0 ? cmp : a.key.localeCompare(b.key);
});

/** 出力（TypeScriptに “order” を含める） */
const OUT_DIR = path.join(process.cwd(), "generated");
fs.mkdirSync(OUT_DIR, { recursive: true });

const header =
  `// @generated by scripts/build-post-index.mjs. DO NOT EDIT.\n` +
  `/* eslint-disable */\n\n` +
  `export type PostMeta = {\n` +
  `  title: string;\n  slug: string;\n  excerpt?: string;\n  tags?: string[];\n  date?: string;\n  sectionKey: string;\n  subKey: string;\n  order?: number;\n  subOrder?: number;\n` +
  `};\n` +
  `export type SubIndex = { key: string; posts: PostMeta[]; order?: number };\n` +
  `export type SectionIndex = { key: string; subs: SubIndex[]; order?: number };\n\n`;

const body =
  `const data: { sections: SectionIndex[] } = ${JSON.stringify({ sections }, null, 2)};\n\n` +
  `export default data;\n`;

fs.writeFileSync(path.join(OUT_DIR, "post-index.ts"), header + body, "utf-8");
console.log(`[post-index] Wrote generated/post-index.ts (${sections.length} sections)`);
